<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SVG Color Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
    }
    #canvas {
      background-color: grey;
    }
    .swatch {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin: 5px;
      position: relative;
      cursor: pointer;
    }
    .cross {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }
  </style>
</head>
<body>

<h1>SVG Color Editor</h1>

<canvas id="canvas" resize></canvas>
<div id="swatches"></div>
<button onclick="downloadSVG()">Download SVG</button>

<script>
  paper.setup('canvas');

  // Initialize color map
  let colorMap = {};

  // Recursive function to flatten SVG and populate colorMap
  function flattenSVG(item) {
    if (item.children) {
      item.children.forEach(flattenSVG);
    }
    if (item.fillColor) {
      let color = item.fillColor.toCSS(true);
      if (!colorMap[color]) {
        colorMap[color] = [];
      }
      colorMap[color].push(item);
    }
  }

  // Load SVG
  const urlParams = new URLSearchParams(window.location.search);
  const svgUrl = urlParams.get('svg');
  if (svgUrl) {
    fetch(svgUrl)
      .then(response => response.text())
      .then(data => {
        paper.project.importSVG(data, {
          expandShapes: true,
          onLoad: (item) => {
            paper.view.viewSize = item.bounds.size;
            flattenSVG(item);
            console.log('Color Map:', colorMap); // Debugging
            populateSwatches();
          }
        });
      });
  }

  // Populate swatches
  function populateSwatches() {
    const swatches = document.getElementById('swatches');
    Object.keys(colorMap).forEach(color => {
      const swatch = document.createElement('div');
      swatch.className = 'swatch';
      swatch.style.backgroundColor = color;
      swatch.addEventListener('click', () => toggleColor(color, swatch));
      swatches.appendChild(swatch);
    });
  }

  // Toggle color
  function toggleColor(color, swatch) {
    const paths = colorMap[color];
    if (paths) {
      const firstPath = paths[0];
      if (firstPath.visible) {
        paths.forEach(path => path.visible = false);
        const cross = document.createElement('div');
        cross.className = 'cross';
        cross.style.backgroundImage = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='black'><path d='M0 0h24v24H0z' fill='none'/><path d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/></svg>")`;
        swatch.appendChild(cross);
      } else {
        paths.forEach(path => path.visible = true);
        swatch.innerHTML = '';
      }
    }
  }

  // Download SVG
  function downloadSVG() {
    const svg = paper.project.exportSVG({ asString: true });
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'edited.svg';
    a.click();
    URL.revokeObjectURL(url);
  }
</script>

</body>
</html>
